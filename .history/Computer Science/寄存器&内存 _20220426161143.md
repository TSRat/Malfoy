# 寄存器&内存
* ALU计算后的结果若丢弃了则无意义，所以需要找个方式进行**存储**，可能还需要进行**多个连续操作**，这就用到了计算机内存
* **随机存取存储器**（Random Access Memory, RAM）：只能在有电的情况下存储东西，比如游戏状态，断电数据即损失
* **持久存储**（persistent memory）：电源关闭时数据也不会丢失，它用来存其他东西
* **锁存器**：存储1位数据的电路
  * 需要**回向电路**，即把输出连回输入
  * **OR门**：两个输入分别为A和B，将输出连回输入B；首先两个输入都设为0，则电路的输出为0，如果将A变为1，则输出为1，输出回到B，OR门的两个输入都是1，则输出不变，此时该电路能记录“1”，但是问题是这个记录是永久的，**无论怎么改变输入A都没办法从1变回0**
  ![](../images/锁存器.png)
  * **AND门**：两个输入分别为A和B，将输出连回输入B。开始时将A和B都设为1，则输出1，之后将A设为0，则输出会变成0，这个电路能记录0，并且**无论A设为什么值该电路都始终输出0**
  ![](../images/锁存器2.png)
  * **AND-OR锁存器**（AND-OR latch）：有两个输入，“设置”（SET）输入把输出变成1，“复位”（RESET）输入把输出变成0，如果SET和RESET都是0，电路会输出最后放入的内容，即存储了1位的信息；这叫“锁存”（latch）是因为它“锁定”了一个值，放入数据的动作叫“写入”（writing），拿出数据的动作叫“读取”（reading）
  ![](../images/锁存器3.png)
* **门锁**：为了方便使用，增加逻辑门将AND-OR锁存器改为“门锁”（Gated Latch），两个输入为**数据输入**（data input）和**允许写入**线（write enable），一个输出为**数据输出**（data output）
![](../images/门锁.png)
  * 将门锁**抽象化**（不关心内部的逻辑门实现），初始化数据输入和允许写入线都是0，数据输出也是0，此时数据输入从0换到1或从1换到0什么也不会改变——输出依旧为0，这是因为允许写入线是关闭的，所以内容不会变化；将允许写入线输入为1，此时数据输入设为1，1就能存起来，数据输出此时为1，现在关闭允许写入线，输出会保持1，不管数据输入怎么变化，数据输出都不会改变
  ![](../images/门锁抽象化.png)
* **寄存器**（register）：并排放置的**n个锁存器**，可以存储**n位信息**；寄存器能存一个数字，这个数字有多少位叫做“**位宽**”（width）；早期电脑用8位寄存器，然后是16位，32位，如今许多计算机都有64位宽的寄存器
  * 在写入寄存器之前需要先启用里面所有的锁存器，可以**用一根线连接所有“允许写入线”**，把它设为1，然后**用8条数据线发数据**，然后**将“允许写入线”设回0**，这样8位的数据就存储完成
  ![](../images/8位寄存器.png)
  * 若只有很少的位，把锁存器并排放置可以勉强解决问题，但64位寄存器需要64根数据线，64根连到输出端，1根线启用所有锁存器，加起来需要129根线；解决线过多的方法就是使用矩阵
* **门锁矩阵**
  * 在矩阵中不并列排放锁存器，而是做成**网格**；可以用16*16网格的锁存器存储256位，要启用某个锁存器时就打开**相应的行线和列线**，需要打开交叉处锁存器的“允许写入线”，所有其他的锁存器保持关闭，所以可以用AND门，只有行线和列线都是1时AND门才输出1，用于选择单个锁存器
  ![](../images/门锁矩阵.png)
  * 这种行列排列法用**一根“允许写入线”**连所有锁存器，为了让锁存器变成允许写入，**行线，列线和“允许写入线”都必须是1**，并且每次只有一个锁存器会启用，这代表我们可以只用**一根数据线**连接所有锁存器来传数据，因为只有一个锁存器会启用，只有它会存数据，其他锁存器由于没有允许写入所以会忽略数据线上的值；我们可以使用类似的技巧做“允许读取线”来从一个指定的锁存器读取数据
  * 所以对于256位的存储只要35条线，1条“数据线”，1条“允许写入线”，1条“允许读取线”，还有16行16列的线用于选择锁存器
  ![](../images/门锁矩阵2.png)
* **多路复用器（译码器）**（multiplexer）
  * 需要选择方法来唯一指定存储位置——地址（记忆地址），为了将地址转成多行和列，需要“多路复用器”；一个多路复用器以处理行，另一个多路复用器处理列（如第12行第8列：11001000）
  ![](../images/多路复用器.png)
  * 把 256 位分配分配地址：它输入一个 8 位，4 位代表列，4 位代表行，需要允许写入和允许读取线，还需要一条数据线用于写入数据
  ![](../images/256bit.png)
  * 范围扩大，将多个 256 位内存并排排列，每行 8 个，可以存 256 个 8 位（一个字节）数字，即 **256 个字节**（每个 256 位内存只能存某个 8 位数字中的 1 位，但可以存256个这样的“ 1 位”），同时给 8 个 256 位内存**一样的地址**，每8个一样的地址存一个8位数字
  ![](../images/8256.png)
  * 可以抽象化为一个**整体的可寻址内存**，有256个地址，每个地址能读或写一个8位值
  ![](../images/RAM.png)
* **现代发展**
  * 现代计算机的内存扩展到上兆字节（MB）和千兆字节（GB）的方式，随着内存地址的增多，内存地址也必须增长，8位最多能代表256个内存地址，要给千兆或十亿字节的内存寻址则需要32位地址；内存的一个重要特性是可以随时访问任何位置，因此叫**随机存取存储器（RAM）**
  * 如今用锁存器做了一块静态随机存取存储器（**SRAM**），还有其他类型的RAM，如DRAM，闪存和NVRAM，它们在功能上与SRAM相似，但是用不同的电路存单个位，比如用不同的逻辑门，电容器，charge traps或忆阻器，但根本上这些技术都是矩阵层层嵌套来存储大量信息